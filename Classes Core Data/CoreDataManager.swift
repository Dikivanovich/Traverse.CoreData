import UIKitimport CoreDataclass CoreDataManager {        //    Singleton        static let instance = CoreDataManager()        private init() {}        // MARK: - Core Data stack        lazy var persistentContainer: NSPersistentContainer = {    /*    The persistent container for the application. This implementation    creates and returns a container, having loaded the store for the    application to it. This property is optional since there are legitimate    error conditions that could cause the creation of the store to fail.    */    let container = NSPersistentContainer(name: "Traverse_CoreData")    container.loadPersistentStores(completionHandler: { (storeDescription, error) in    if let error = error as NSError? {    // Replace this implementation with code to handle the error appropriately.    // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.        /*    Typical reasons for an error here include:    * The parent directory does not exist, cannot be created, or disallows writing.    * The persistent store is not accessible, due to permissions or data protection when the device is locked.    * The device is out of space.    * The store could not be migrated to the current model version.    Check the error message to determine what the actual problem was.    */    fatalError("Unresolved error \(error), \(error.userInfo)")    }    })    return container    }()        // MARK: - Core Data Saving support        func saveContext () {    let context = self.persistentContainer.viewContext    if context.hasChanges {    do {    try context.save()} catch {    // Replace this implementation with code to handle the error appropriately.    // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.    let nserror = error as NSError    fatalError("Unresolved error \(nserror), \(nserror.userInfo)")    }    }    }        func entityForNAme(entityName: String) -> NSEntityDescription {    return NSEntityDescription.entity(forEntityName: entityName, in: CoreDataManager.instance.persistentContainer.viewContext)!    }        //    MARK: - Создание контроллера данных:        func returnFetchedResultsControllerStation() -> NSFetchedResultsController<Station>  {        let fetchRequest: NSFetchRequest<Station> = Station.fetchRequest()    let sortDescriptorNameStation = NSSortDescriptor(key: "dateInitStation", ascending: true)    fetchRequest.sortDescriptors = [sortDescriptorNameStation]    let fetchedResultsController = NSFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: CoreDataManager.instance.persistentContainer.viewContext, sectionNameKeyPath: nil, cacheName: nil)    fetchRequest.returnsObjectsAsFaults = false        return fetchedResultsController        }        //    MARK: - Добавление новой фиксированной станции:        func addNewStation(name nameStation: String, x: String, y: String, z: String) {    let managedObject = NSEntityDescription.insertNewObject(forEntityName: "Station", into: CoreDataManager.instance.persistentContainer.viewContext) as! Station        managedObject.nameStation = nameStation    managedObject.dateInitStation = CurrentData.instance.returnDate()    managedObject.fixed = true    managedObject.x = NumberFormatter().number(from: x)?.decimalValue as NSDecimalNumber?    managedObject.y = NumberFormatter().number(from: y)?.decimalValue as NSDecimalNumber?    managedObject.z = NumberFormatter().number(from: z)?.decimalValue as NSDecimalNumber?        CoreDataManager.instance.saveContext()        print("\n\(self)Станция добавлена, теперь список станций такой:")        let fetchRequest: NSFetchRequest<Station> = Station.fetchRequest()        do {    let results = try CoreDataManager.instance.persistentContainer.viewContext.fetch(fetchRequest)        for result in results as [Station] {    var fixedSt = String()    if result.fixed == true {    fixedSt = "Фиксированная"    } else {        fixedSt = "Вычисляемая"        }        print("Станция: \(result.nameStation!), категория: \(fixedSt)")        }    } catch  {        print(error)    }        }        //    MARK: - Добавление новой вычисляемой станции:        func addNewStation(name nameStation: String) {        let managedObject = NSEntityDescription.insertNewObject(forEntityName: "Station", into: CoreDataManager.instance.persistentContainer.viewContext) as! Station        managedObject.nameStation = nameStation    managedObject.dateInitStation = CurrentData.instance.returnDate()    managedObject.fixed = false        CoreDataManager.instance.saveContext()        print("\n\(self)Станция добавлена, теперь список станций такой:")        let fetchRequest: NSFetchRequest<Station> = Station.fetchRequest()        do {        let results = try CoreDataManager.instance.persistentContainer.viewContext.fetch(fetchRequest)        for result in results as [Station] {        var fixedSt = String()        if result.fixed == true {        fixedSt = "Фиксированная"    } else {        fixedSt = "Вычисляемая"        }        print("Станция: \(result.nameStation!), категория: \(fixedSt)")        }    } catch  {        print(error)        }}    //MARK: - Добавление новой станции из журнала измерений:        func addNewStationFromMeasureList (point selectedPoint: Points, x: String?, y: String?, z: String?, fromStation: Station,  distance: String, hzAngle: MeasurementAngle, vAngle: MeasurementAngle?, backSide: Bool) {    //MARK:   • Инициализация станции, заполнение переменных:        let station = NSEntityDescription.insertNewObject(forEntityName: "Station", into: CoreDataManager.instance.persistentContainer.viewContext) as! Station        station.nameStation = selectedPoint.namePoint!  // имя станции    station.dateInitStation = CurrentData.instance.returnDate()  // время создания записи        //    Проверка наличия координат точки при создании станции:    if x != "" && y != "" && z != "" {    station.fixed = true    station.x = NumberFormatter().number(from: x!)?.decimalValue as NSDecimalNumber?    station.y = NumberFormatter().number(from: y!)?.decimalValue as NSDecimalNumber?    station.z = NumberFormatter().number(from: z!)?.decimalValue as NSDecimalNumber?} else {    station.fixed = false    }    //MARK:   • Инициализация отчета по горизонтальному лимбу, заполнение свойств:        let horizontalAngle = NSEntityDescription.insertNewObject(forEntityName: "HorizontalAngle", into: CoreDataManager.instance.persistentContainer.viewContext) as! HorizontalAngle    horizontalAngle.degree = hzAngle.degree! // градусы    horizontalAngle.minutes = hzAngle.minutes! // минуты    horizontalAngle.seconds = hzAngle.seconds! // секунды    //MARK:   • Инициализация отчета по вертикальному лимбу, заполнение свойств:    let verticalAngle = NSEntityDescription.insertNewObject(forEntityName: "VerticalAngle", into: CoreDataManager.instance.persistentContainer.viewContext) as! VerticalAngle        //    Проверка наличия отчета по вертикальному лимбу и запись его:    if vAngle != nil {        verticalAngle.degree = (vAngle?.degree!)! // градусы        verticalAngle.minutes = (vAngle?.minutes!)!  //минуты        verticalAngle.seconds = (vAngle?.seconds!)!  //секунды    }//MARK:   • Инициализация "заднего" измерения:    let backSideMeasureStation = NSEntityDescription.insertNewObject(forEntityName: "MeasurementsToStationBackSide", into: CoreDataManager.instance.persistentContainer.viewContext) as! MeasurementsToStationBackSide    //MARK:   • Инициализация "переднего" измерения:    let forwardSideMeasureStation = NSEntityDescription.insertNewObject(forEntityName: "MeasurementsToStationForwardSide", into: CoreDataManager.instance.persistentContainer.viewContext) as! MeasurementsToStationForwardSide    //MARK:   • Проверка передней, задней точки, запись данных по условию:        if backSide == true {                backSideMeasureStation.addToHorizontalAngle(horizontalAngle)        backSideMeasureStation.addToVerticalAngle(verticalAngle)        backSideMeasureStation.distance = NumberFormatter().number(from: distance)!.int16Value        fromStation.addToMeasurementsToStationBackSide(backSideMeasureStation)        print("\n\(self)Передняя точка добавлена в \(fromStation.nameStation!)")            } else {                forwardSideMeasureStation.addToHorizontalAngle(horizontalAngle)        forwardSideMeasureStation.addToVerticalAngle(verticalAngle)        forwardSideMeasureStation.distance = NumberFormatter().number(from: distance)!.int16Value        fromStation.addToMeasurementsToStationForwardSide(forwardSideMeasureStation)        print("\n\(self)Задняя точка добавлена в \(fromStation.nameStation!)")        }        CoreDataManager.instance.saveContext()        print("\n\(self)Станция добавлена, теперь список станций такой:")        let fetchRequest: NSFetchRequest<Station> = Station.fetchRequest()        do {        let stations = try CoreDataManager.instance.persistentContainer.viewContext.fetch(fetchRequest)                for stationFetch in stations as [Station] {        var fixedSt = String()        if stationFetch.fixed == true {            fixedSt = "Фиксированная"        } else {                fixedSt = "Вычисляемая"                }                print("Станция: \(stationFetch.nameStation!), категория: \(fixedSt)")                }            } catch  {                print(error)        }}        //    MARK: - Добавление новой фиксированной точки:        func addNewMeasure (name namePoint: String, x: String, y: String, z: String, fromStation: Station,  distance: String, hzAngle: MeasurementAngle, vAngle: MeasurementAngle?) {                let point:Points = NSEntityDescription.insertNewObject(forEntityName: "Points", into: CoreDataManager.instance.persistentContainer.viewContext) as! Points                point.dateMeasure = CurrentData.instance.returnDate()        point.namePoint = namePoint        point.x = NumberFormatter().number(from: x)?.decimalValue as NSDecimalNumber?        point.y = NumberFormatter().number(from: y)?.decimalValue as NSDecimalNumber?        point.z = NumberFormatter().number(from: z)?.decimalValue as NSDecimalNumber?        point.fixed = true                let horizontalAngle: MeasurementsToPointHz = NSEntityDescription.insertNewObject(forEntityName: "MeasurementsToPointHz", into: CoreDataManager.instance.persistentContainer.viewContext) as! MeasurementsToPointHz                let verticalAngle: MeasurementsToPointVz = NSEntityDescription.insertNewObject(forEntityName: "MeasurementsToPointVz", into: CoreDataManager.instance.persistentContainer.viewContext) as! MeasurementsToPointVz                horizontalAngle.degree = hzAngle.degree!        horizontalAngle.minutes = hzAngle.minutes!        horizontalAngle.seconds = hzAngle.seconds!        horizontalAngle.distance = NumberFormatter().number(from: distance)?.decimalValue as NSDecimalNumber?            verticalAngle.degree = vAngle?.degree as NSObject?        verticalAngle.minutes = vAngle?.minutes  as NSObject?        verticalAngle.seconds = vAngle?.seconds as NSObject?        point.addToMesureFromStationVz(verticalAngle)        fromStation.addToMeasurementsToPointVz(verticalAngle)            //    добавление связи точки со станцией:                point.addToMesureFromStationHz(horizontalAngle)        fromStation.addToPoint(point)        fromStation.addToMeasurementsToPointHz(horizontalAngle)                CoreDataManager.instance.saveContext()            }        //    MARK: - Добавление новой вычисляемой точки наблюдения:        /// Данная функция создает запись сущности Points с атрибутами x, y, z равными nil, добавляет дату записи точки, статус вычисляемого положения станции, а так же добавляет связь к сущности Station at IndexPath    ///    /// - Parameters:    ///   - namePoint: String - Имя точки присваивается атрибуту экземпляра сущности Points    ///   - fromStation: Station - Станция, выбранная из списка по IndexPath    func addNewMeasure (name namePoint: String, fromStation: Station, distance: String, hzAngle: MeasurementAngle, vAngle: MeasurementAngle?) {                let point: Points = NSEntityDescription.insertNewObject(forEntityName: "Points", into: CoreDataManager.instance.persistentContainer.viewContext) as! Points                let horizontalAngle: MeasurementsToPointHz = NSEntityDescription.insertNewObject(forEntityName: "MeasurementsToPointHz", into: CoreDataManager.instance.persistentContainer.viewContext) as! MeasurementsToPointHz                let verticalAngle: MeasurementsToPointVz = NSEntityDescription.insertNewObject(forEntityName: "MeasurementsToPointVz", into: CoreDataManager.instance.persistentContainer.viewContext) as! MeasurementsToPointVz                point.dateMeasure = CurrentData.instance.returnDate()        point.namePoint = namePoint        point.fixed = false                horizontalAngle.degree = hzAngle.degree!        horizontalAngle.minutes = hzAngle.minutes!        horizontalAngle.seconds = hzAngle.seconds!        horizontalAngle.distance = NumberFormatter().number(from: distance)?.decimalValue as NSDecimalNumber?            verticalAngle.degree = vAngle?.degree as NSObject?        verticalAngle.minutes = vAngle?.minutes as NSObject?        verticalAngle.seconds = vAngle?.seconds as NSObject?        point.addToMesureFromStationVz(verticalAngle)        fromStation.addToMeasurementsToPointVz(verticalAngle)            //    добавление связи точки со станцией, измерения со станции и измерения на точку:        point.addToMesureFromStationHz(horizontalAngle)        fromStation.addToPoint(point)        fromStation.addToMeasurementsToPointHz(horizontalAngle)                CoreDataManager.instance.saveContext()            }    }