import UIKitimport CoreDataclass CoreDataManager {        //    Singleton        static let instance = CoreDataManager()        private init() {}        // MARK: - Core Data stack        lazy var persistentContainer: NSPersistentContainer = {    /*    The persistent container for the application. This implementation    creates and returns a container, having loaded the store for the    application to it. This property is optional since there are legitimate    error conditions that could cause the creation of the store to fail.    */    let container = NSPersistentContainer(name: "Traverse_CoreData")    container.loadPersistentStores(completionHandler: { (storeDescription, error) in    if let error = error as NSError? {    // Replace this implementation with code to handle the error appropriately.    // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.        /*    Typical reasons for an error here include:    * The parent directory does not exist, cannot be created, or disallows writing.    * The persistent store is not accessible, due to permissions or data protection when the device is locked.    * The device is out of space.    * The store could not be migrated to the current model version.    Check the error message to determine what the actual problem was.    */    fatalError("Unresolved error \(error), \(error.userInfo)")    }    })    return container    }()        // MARK: - Core Data Saving support        func saveContext () {    let context = self.persistentContainer.viewContext    if context.hasChanges {    do {    try context.save()} catch {    // Replace this implementation with code to handle the error appropriately.    // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.    let nserror = error as NSError    fatalError("Unresolved error \(nserror), \(nserror.userInfo)")    }    }    }            func entityForNAme(entityName: String) -> NSEntityDescription {    return NSEntityDescription.entity(forEntityName: entityName, in: CoreDataManager.instance.persistentContainer.viewContext)!    }                //    MARK: - Создание контроллера данных:        func returnFetchedResultsControllerStation() -> NSFetchedResultsController<Station>  {        let fetchRequest: NSFetchRequest<Station> = Station.fetchRequest()    let sortDescriptorNameStation = NSSortDescriptor(key: "dateInitStation", ascending: true)    fetchRequest.sortDescriptors = [sortDescriptorNameStation]    let fetchedResultsController = NSFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: CoreDataManager.instance.persistentContainer.viewContext, sectionNameKeyPath: nil, cacheName: nil)    fetchRequest.returnsObjectsAsFaults = false        return fetchedResultsController            }        //    MARK: - Добавление новой фиксированной станции:        func addNewStation(name nameStation: String, x: String, y: String, z: String) {    let managedObject = NSEntityDescription.insertNewObject(forEntityName: "Station", into: CoreDataManager.instance.persistentContainer.viewContext) as! Station        managedObject.nameStation = nameStation    managedObject.dateInitStation = CurrentData.instance.returnDate()    managedObject.fixed = true    managedObject.x = NumberFormatter().number(from: x)?.decimalValue as NSDecimalNumber?    managedObject.y = NumberFormatter().number(from: y)?.decimalValue as NSDecimalNumber?    managedObject.z = NumberFormatter().number(from: z)?.decimalValue as NSDecimalNumber?        CoreDataManager.instance.saveContext()        print("Станция добавлена, теперь список станций такой:")        let fetchRequest: NSFetchRequest<Station> = Station.fetchRequest()            do {    let results = try CoreDataManager.instance.persistentContainer.viewContext.fetch(fetchRequest)        for result in results as [Station] {    var fixedSt = String()    if result.fixed == true {    fixedSt = "Фиксированная"    } else {        fixedSt = "Вычисляемая"            }        print("Станция: \(result.nameStation!), категория: \(fixedSt)")        }    } catch  {        print(error)    }            }            //    MARK: - Добавление новой вычисляемой станции:        func addNewStation(name nameStation: String) {                let managedObject = NSEntityDescription.insertNewObject(forEntityName: "Station", into: CoreDataManager.instance.persistentContainer.viewContext) as! Station        managedObject.nameStation = nameStation    managedObject.dateInitStation = CurrentData.instance.returnDate()    managedObject.fixed = false        CoreDataManager.instance.saveContext()        print("Станция добавлена, теперь список станций такой:")        let fetchRequest: NSFetchRequest<Station> = Station.fetchRequest()        do {        let results = try CoreDataManager.instance.persistentContainer.viewContext.fetch(fetchRequest)        for result in results as [Station] {        var fixedSt = String()        if result.fixed == true {        fixedSt = "Фиксированная"    } else {        fixedSt = "Вычисляемая"        }        print("Станция: \(result.nameStation!), категория: \(fixedSt)")        }    } catch  {        print(error)        }    }            //    MARK: - Добавление новой станции из журнала измерений:        func addNewStationFromMeasureList (name nameStation: String, x: String?, y: String?, z: String?, fromStation: Station,  distance: String, hzAngle: MeasurementAngle, vAngle: MeasurementAngle?, backSide: Bool, point deletedPoint: Points) {        let station = NSEntityDescription.insertNewObject(forEntityName: "Station", into: CoreDataManager.instance.persistentContainer.viewContext) as! Station    //    let forwardMeasure = fromStation.measurementsToStationForwardSide as! MeasurementsToStationForwardSide//    let backSideMeasure = fromStation.measurementsToStationBackSide as! MeasurementsToStationBackSide        station.nameStation = nameStation    station.dateInitStation = CurrentData.instance.returnDate()        //    Проверка наличия координат точки при создании станции    if x != nil && y != nil && z != nil {    station.fixed = true    station.x = NumberFormatter().number(from: x!)?.decimalValue as NSDecimalNumber?    station.y = NumberFormatter().number(from: y!)?.decimalValue as NSDecimalNumber?    station.z = NumberFormatter().number(from: z!)?.decimalValue as NSDecimalNumber?} else {    station.fixed = false    }                        CoreDataManager.instance.saveContext()        print("Станция добавлена, теперь список станций такой:")        let fetchRequest: NSFetchRequest<Station> = Station.fetchRequest()            do {    let results = try CoreDataManager.instance.persistentContainer.viewContext.fetch(fetchRequest)        for result in results as [Station] {    var fixedSt = String()    if result.fixed == true {    fixedSt = "Фиксированная"    } else {        fixedSt = "Вычисляемая"            }        print("Станция: \(result.nameStation!), категория: \(fixedSt)")        }    } catch  {        print(error)    }                        }            //    MARK: - Добавление новой фиксированной точки:        func addNewMeasure (name namePoint: String, x: String, y: String, z: String, fromStation: Station,  distance: String, hzAngle: MeasurementAngle, vAngle: MeasurementAngle?) {            let managedObjectPoints:Points = NSEntityDescription.insertNewObject(forEntityName: "Points", into: CoreDataManager.instance.persistentContainer.viewContext) as! Points        managedObjectPoints.dateMeasure = CurrentData.instance.returnDate()    managedObjectPoints.namePoint = namePoint    managedObjectPoints.x = NumberFormatter().number(from: x)?.decimalValue as NSDecimalNumber?    managedObjectPoints.y = NumberFormatter().number(from: y)?.decimalValue as NSDecimalNumber?    managedObjectPoints.z = NumberFormatter().number(from: z)?.decimalValue as NSDecimalNumber?    managedObjectPoints.fixed = true        let managedObjectMeasurementsToPointHz: MeasurementsToPointHz = NSEntityDescription.insertNewObject(forEntityName: "MeasurementsToPointHz", into: CoreDataManager.instance.persistentContainer.viewContext) as! MeasurementsToPointHz        let managedObjectMeasurementsToPointVz: MeasurementsToPointVz = NSEntityDescription.insertNewObject(forEntityName: "MeasurementsToPointVz", into: CoreDataManager.instance.persistentContainer.viewContext) as! MeasurementsToPointVz        managedObjectMeasurementsToPointHz.degree = hzAngle.degree!    managedObjectMeasurementsToPointHz.minutes = hzAngle.minutes!    managedObjectMeasurementsToPointHz.seconds = hzAngle.seconds!    managedObjectMeasurementsToPointHz.distance = NumberFormatter().number(from: distance)?.decimalValue as NSDecimalNumber?            managedObjectMeasurementsToPointVz.degree = vAngle?.degree as NSObject?    managedObjectMeasurementsToPointVz.minutes = vAngle?.minutes  as NSObject?    managedObjectMeasurementsToPointVz.seconds = vAngle?.seconds as NSObject?    managedObjectPoints.addToMesureFromStationVz(managedObjectMeasurementsToPointVz)    fromStation.addToMeasurementsToPointVz(managedObjectMeasurementsToPointVz)                        //    добавление связи точки со станцией:        managedObjectPoints.addToMesureFromStationHz(managedObjectMeasurementsToPointHz)    fromStation.addToPoint(managedObjectPoints)    fromStation.addToMeasurementsToPointHz(managedObjectMeasurementsToPointHz)        CoreDataManager.instance.saveContext()        }        //    MARK: - Добавление новой вычисляемой точки наблюдения:        /// Данная функция создает запись сущности Points с атрибутами x, y, z равными nil, добавляет дату записи точки, статус вычисляемого положения станции, а так же добавляет связь к сущности Station at IndexPath    ///    /// - Parameters:    ///   - namePoint: String - Имя точки присваивается атрибуту экземпляра сущности Points    ///   - fromStation: Station - Станция, выбранная из списка по IndexPath    func addNewMeasure (name namePoint: String, fromStation: Station, distance: String, hzAngle: MeasurementAngle, vAngle: MeasurementAngle?) {        let managedPoints:Points = NSEntityDescription.insertNewObject(forEntityName: "Points", into: CoreDataManager.instance.persistentContainer.viewContext) as! Points        let managedMeasurementsToPointHz: MeasurementsToPointHz = NSEntityDescription.insertNewObject(forEntityName: "MeasurementsToPointHz", into: CoreDataManager.instance.persistentContainer.viewContext) as! MeasurementsToPointHz        let managedMeasurementsToPointVa: MeasurementsToPointVz = NSEntityDescription.insertNewObject(forEntityName: "MeasurementsToPointVz", into: CoreDataManager.instance.persistentContainer.viewContext) as! MeasurementsToPointVz        managedPoints.dateMeasure = CurrentData.instance.returnDate()    managedPoints.namePoint = namePoint    managedPoints.fixed = false        managedMeasurementsToPointHz.degree = hzAngle.degree!    managedMeasurementsToPointHz.minutes = hzAngle.minutes!    managedMeasurementsToPointHz.seconds = hzAngle.seconds!    managedMeasurementsToPointHz.distance = NumberFormatter().number(from: distance)?.decimalValue as NSDecimalNumber?            managedMeasurementsToPointVa.degree = vAngle?.degree as NSObject?    managedMeasurementsToPointVa.minutes = vAngle?.minutes as NSObject?    managedMeasurementsToPointVa.seconds = vAngle?.seconds as NSObject?    managedPoints.addToMesureFromStationVz(managedMeasurementsToPointVa)    fromStation.addToMeasurementsToPointVz(managedMeasurementsToPointVa)            //    добавление связи точки со станцией, измерения со станции и измерения на точку:    managedPoints.addToMesureFromStationHz(managedMeasurementsToPointHz)    fromStation.addToPoint(managedPoints)    fromStation.addToMeasurementsToPointHz(managedMeasurementsToPointHz)        CoreDataManager.instance.saveContext()                }    }